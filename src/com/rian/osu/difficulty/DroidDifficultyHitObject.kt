package com.rian.osu.difficulty

import com.rian.osu.GameMode
import com.rian.osu.beatmap.hitobject.*
import com.rian.osu.mods.Mod
import com.rian.osu.mods.ModTraceable
import kotlin.math.max
import kotlin.math.min
import kotlin.math.pow

/**
 * Represents a [HitObject] with additional information for osu!droid difficulty calculation.
 */
class DroidDifficultyHitObject(
    /**
     * The [HitObject] that this [DroidDifficultyHitObject] wraps.
     */
    obj: HitObject,

    /**
     * The [HitObject] that occurs before [obj].
     */
    lastObj: HitObject?,

    /**
     * The clock rate being calculated.
     */
    clockRate: Double,

    /**
     * Other hit objects in the beatmap, including this hit object.
     */
    difficultyHitObjects: Array<DroidDifficultyHitObject>,

    /**
     * The index of this hit object in the list of all hit objects.
     *
     * This is one less than the actual index of the hit object in the beatmap.
     */
    index: Int
) : DifficultyHitObject(obj, lastObj, clockRate, difficultyHitObjects, index) {
    override val mode = GameMode.Droid
    override val maximumSliderRadius = NORMALIZED_RADIUS * 2
    override val smallCircleBonus = max(1.0, 1 + ((70 - obj.difficultyRadius) / 50).pow(2))

    /**
     * The rhythm multiplier generated by the [HitObject].
     */
    @JvmField
    var rhythmMultiplier = 1.0

    /**
     * Adjusted preempt time of the [HitObject], taking speed multiplier into account.
     */
    @JvmField
    val timePreempt = obj.timePreempt / clockRate

    override fun previous(backwardsIndex: Int) = if (index - backwardsIndex >= 0) difficultyHitObjects[index - backwardsIndex] else null

    override fun next(forwardsIndex: Int) = if (index + forwardsIndex + 2 < difficultyHitObjects.size) difficultyHitObjects[index + forwardsIndex + 2] else null

    override fun opacityAt(time: Double, mods: Iterable<Mod>): Double {
        // Traceable hides the primary piece of a hit circle (that is, its body), so consider it as fully invisible.
        if (obj is HitCircle && mods.any { it is ModTraceable }) {
            return 0.0
        }

        return super.opacityAt(time, mods)
    }

    /**
     * Determines whether this [DroidDifficultyHitObject] is considered overlapping with the [DroidDifficultyHitObject]
     * before it.
     *
     * Keep in mind that "overlapping" in this case is overlapping to the point where both [DroidDifficultyHitObject]s
     * can be hit with just a single tap in osu!droid.
     *
     * @param considerDistance Whether to consider the distance between both [DroidDifficultyHitObject]s.
     * @returns Whether the [DroidDifficultyHitObject] is considered overlapping.
     */
    fun isOverlapping(considerDistance: Boolean): Boolean {
        if (obj is Spinner) {
            return false
        }

        val previous = previous(0)

        if (previous == null || previous.obj is Spinner) {
            return false
        }

        if (deltaTime >= 5) {
            return false
        }

        if (considerDistance) {
            val position = obj.difficultyStackedPosition
            var distance = previous.obj.difficultyStackedEndPosition.getDistance(position)

            if (previous.lazyEndPosition != null) {
                distance = min(
                    distance,
                    previous.lazyEndPosition!!.getDistance(position)
                )
            }

            return distance <= 2 * obj.difficultyRadius
        }

        return true
    }
}