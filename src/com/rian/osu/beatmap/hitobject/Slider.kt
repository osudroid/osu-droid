package com.rian.osu.beatmap.hitobject

import com.rian.osu.GameMode
import com.rian.osu.beatmap.EmptyHitWindow
import com.rian.osu.beatmap.hitobject.sliderobject.*
import com.rian.osu.beatmap.sections.BeatmapControlPoints
import com.rian.osu.beatmap.sections.BeatmapDifficulty
import com.rian.osu.math.Vector2
import com.rian.osu.utils.Cached
import kotlin.math.min
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.ensureActive

/**
 * Represents a slider.
 */
class Slider(
    /**
     * The time at which this [Slider] starts, in milliseconds.
     */
    startTime: Double,

    /**
     * The position of the [Slider] relative to the play field.
     */
    position: Vector2,

    /**
     * The repetition amount of this [Slider]. Note that 1 repetition means no repeats (1 loop).
     */
    repeatCount: Int,

    /**
     * The path of this [Slider].
     */
    path: SliderPath,

    /**
     * Whether this [Slider] starts a new combo.
     */
    isNewCombo: Boolean,

    /**
     * When starting a new combo, the offset of the new combo relative to the current one.
     *
     * This is generally a setting provided by a beatmap creator to choreograph interesting color patterns
     * which can only be achieved by skipping combo colors with per-[HitObject] level.
     *
     * It is exposed via [HitObject.comboIndexWithOffsets].
     */
    comboOffset: Int,

    /**
     * The samples to be played when each node of this [Slider] is hit.
     *
     * - 0: The first node.
     * - 1: The first repeat.
     * - 2: The second repeat.
     * - ...
     * - `n - 1`: The last repeat.
     * - `n`: The last node.
     */
    @JvmField
    var nodeSamples: MutableList<MutableList<HitSampleInfo>>
) : HitObject(startTime, position, isNewCombo, comboOffset) {
    override val endTime
        get() = startTime + spanCount * path.expectedDistance / velocity

    /**
     * The path of this [Slider].
     */
    var path = path
        set(value) {
            field = value

            updateNestedPositions()
        }

    override var position
        get() = super.position
        set(value) {
            super.position = value

            updateNestedPositions()
        }

    private val endPositionCache = Cached(position)

    override val endPosition: Vector2
        get() {
            if (!endPositionCache.isValid) {
                endPositionCache.value = position + curvePositionAt(1.0)
            }

            return endPositionCache.value
        }

    /**
     * The distance of this [Slider].
     */
    val distance
        get() = path.expectedDistance

    /**
     * The amount of times this [Slider] repeats.
     */
    var repeatCount = repeatCount
        set(value) {
            field = value.coerceAtLeast(0)

            updateNestedPositions()
        }

    /**
     * The amount of times the length of this [Slider] spans.
     */
    val spanCount
        get() = repeatCount + 1

    /**
     * The nested hit objects of this [Slider].
     *
     * Consists of a [SliderHead], [SliderTick]s, [SliderRepeat]s, and a [SliderTail].
     */
    var nestedHitObjects = mutableListOf<SliderHitObject>()
        private set

    /**
     * The computed velocity of this [Slider]. This is the amount of path distance travelled in 1 ms.
     */
    var velocity = 0.0
        private set

    /**
     * Spacing between [SliderTick]s of this [Slider].
     */
    var tickDistance = 0.0
        private set

    /**
     * An extra multiplier that affects the number of [SliderTick]s generated by this [Slider].
     * An increase in this value increases [tickDistance], which reduces the number of ticks generated.
     */
    @JvmField
    var tickDistanceMultiplier = 1.0

    /**
     * Whether [SliderTick]s should be generated by this object.
     *
     * This exists for backwards compatibility with maps that abuse NaN slider velocity behavior on osu!stable (e.g. /b/2628991).
     */
    @JvmField
    var generateTicks = true

    /**
     * The head of the [Slider].
     */
    lateinit var head: SliderHead
        private set

    /**
     * The tail of the [Slider].
     */
    lateinit var tail: SliderTail
        private set

    /**
     * The duration of one span of this [Slider] in milliseconds.
     */
    val spanDuration
        get() = duration / spanCount

    override var stackOffsetMultiplier
        get() = super.stackOffsetMultiplier
        set(value) {
            super.stackOffsetMultiplier = value

            difficultyStackedEndPositionCache.invalidate()
            gameplayStackedEndPositionCache.invalidate()

            nestedHitObjects.forEach { it.stackOffsetMultiplier = value }
        }

    // Difficulty calculation object positions

    private val difficultyStackedEndPositionCache = Cached(position)

    override val difficultyStackedEndPosition: Vector2
        get() {
            if (!difficultyStackedEndPositionCache.isValid) {
                difficultyStackedEndPositionCache.value = endPosition + difficultyStackOffset
            }

            return difficultyStackedEndPositionCache.value
        }

    override var difficultyStackHeight
        get() = super.difficultyStackHeight
        set(value) {
            val wasEqual = super.difficultyStackHeight == value

            super.difficultyStackHeight = value

            if (!wasEqual) {
                difficultyStackedEndPositionCache.invalidate()
                nestedHitObjects.forEach { it.difficultyStackHeight = value }
            }
        }

    override var difficultyScale
        get() = super.difficultyScale
        set(value) {
            val wasEqual = super.difficultyScale == value

            super.difficultyScale = value

            if (!wasEqual) {
                difficultyStackedEndPositionCache.invalidate()
                nestedHitObjects.forEach { it.difficultyScale = value }
            }
        }

    // Gameplay object positions

    private val gameplayStackedEndPositionCache = Cached(endPosition)

    override val gameplayStackedEndPosition: Vector2
        get() {
            if (!gameplayStackedEndPositionCache.isValid) {
                gameplayStackedEndPositionCache.value = endPosition + gameplayStackOffset
            }

            return gameplayStackedEndPositionCache.value
        }

    private val screenSpaceGameplayStackedEndPositionCache =
        Cached(convertPositionToRealCoordinates(gameplayStackedEndPosition))

    override val screenSpaceGameplayStackedEndPosition: Vector2
        get() {
            if (!screenSpaceGameplayStackedEndPositionCache.isValid) {
                screenSpaceGameplayStackedEndPositionCache.value =
                    convertPositionToRealCoordinates(gameplayStackedEndPosition)
            }

            return screenSpaceGameplayStackedEndPositionCache.value
        }

    override var gameplayStackHeight
        get() = super.gameplayStackHeight
        set(value) {
            val wasEqual = super.gameplayStackHeight == value

            super.gameplayStackHeight = value

            if (!wasEqual) {
                gameplayStackedEndPositionCache.invalidate()
                screenSpaceGameplayStackedEndPositionCache.invalidate()

                nestedHitObjects.forEach { it.gameplayStackHeight = value }
            }
        }

    override var gameplayScale
        get() = super.gameplayScale
        set(value) {
            val wasEqual = super.gameplayScale == value

            super.gameplayScale = value

            if (!wasEqual) {
                gameplayStackedEndPositionCache.invalidate()
                screenSpaceGameplayStackedEndPositionCache.invalidate()

                nestedHitObjects.forEach { it.gameplayScale = value }
            }
        }

    override fun applyDefaults(controlPoints: BeatmapControlPoints, difficulty: BeatmapDifficulty, mode: GameMode, scope: CoroutineScope?) {
        super.applyDefaults(controlPoints, difficulty, mode, scope)

        val timingPoint = controlPoints.timing.controlPointAt(startTime)
        val difficultyPoint = controlPoints.difficulty.controlPointAt(startTime)

        val sliderVelocityAsBeatLength = -100 / difficultyPoint.speedMultiplier
        val bpmMultiplier =
            if (sliderVelocityAsBeatLength < 0) (-sliderVelocityAsBeatLength).toFloat().coerceIn(10f, 1000f) / 100.0
            else 1.0

        velocity = BASE_SCORING_DISTANCE * difficulty.sliderMultiplier / (timingPoint.msPerBeat * bpmMultiplier)

        // WARNING: this is intentionally not computed as `BASE_SCORING_DISTANCE * difficulty.sliderMultiplier`
        // for backwards compatibility reasons (intentionally introducing floating point errors to match osu!stable).
        val scoringDistance = velocity * timingPoint.msPerBeat

        generateTicks = difficultyPoint.generateTicks

        tickDistance =
            if (generateTicks) scoringDistance / difficulty.sliderTickRate * tickDistanceMultiplier
            else Double.POSITIVE_INFINITY

        // Invalidate the end position in case there are timing changes.
        invalidateEndPositions()

        createNestedHitObjects(controlPoints, scope)

        nestedHitObjects.forEach { it.applyDefaults(controlPoints, difficulty, mode, scope) }
    }

    override fun applySamples(controlPoints: BeatmapControlPoints, scope: CoroutineScope?) {
        val sampleControlPoint = controlPoints.sample.controlPointAt(startTime + CONTROL_POINT_LENIENCY + 1)

        samples = samples.map {
            scope?.ensureActive()

            sampleControlPoint.applyTo(it)
        }.toMutableList()

        nodeSamples.forEachIndexed { i, sampleList ->
            scope?.ensureActive()

            val time = startTime + i * spanDuration + CONTROL_POINT_LENIENCY
            val nodeSamplePoint = controlPoints.sample.controlPointAt(time)

            nodeSamples[i] = sampleList.map {
                scope?.ensureActive()

                nodeSamplePoint.applyTo(it)
            }.toMutableList()
        }

        createSlidingSamples(controlPoints, scope)
        updateNestedSamples(controlPoints, scope)
    }

    /**
     * Computes the position on this [Slider] relative to how much of this [Slider] has been completed in osu!pixels.
     *
     * @param progress `[0. 1]` where 0 is the start time of this [Slider] and 1 is the end time of this [Slider].
     * @return The position on the [Slider].
     */
    fun curvePositionAt(progress: Double) = path.positionAt(progressAt(progress))

    /**
     * Computes the progress along this [Slider] relative to how much of this [Slider] has been completed.
     *
     * @param progress `[0. 1]` where 0 is the start time of this [Slider] and 1 is the end time of this [Slider].
     * @return `[0, 1]` where 0 is the beginning of this [Slider] and 1 is the end of this [Slider].
     */
    fun progressAt(progress: Double): Double {
        var p = progress * spanCount % 1

        if (spanAt(progress) % 2 == 1) {
            p = 1 - p
        }

        return p
    }

    /**
     * Determines which span of this [Slider] the progress point is on.
     *
     * @param progress `[0. 1]` where 0 is the start time of this [Slider] and 1 is the end time of this [Slider].
     * @return `[0, [spanCount])` where 0 is the first run.
     */
    fun spanAt(progress: Double) = (progress * spanCount).toInt()

    override fun createHitWindow(mode: GameMode) = EmptyHitWindow()

    private fun createNestedHitObjects(controlPoints: BeatmapControlPoints, scope: CoroutineScope?) {
        nestedHitObjects.clear()

        head = SliderHead(startTime, position)
        nestedHitObjects.add(head)

        // A very lenient maximum length of a slider for ticks to be generated.
        // This exists for edge cases such as /b/1573664 where the beatmap has been edited by the user, and should never be reached in normal usage.
        val maxLength = 100000.0
        val length = min(maxLength, path.expectedDistance)
        val tickDistance = tickDistance.coerceIn(0.0, length)
        val minDistanceFromEnd = velocity * 10

        for (span in 0 until spanCount) {
            scope?.ensureActive()

            if (tickDistance != 0.0) {
                val spanStartTime = startTime + span * spanDuration
                val reversed = span % 2 == 1
                val sliderTicks = mutableListOf<SliderTick>()

                var d = tickDistance
                while (d <= length) {
                    scope?.ensureActive()

                    if (d >= length - minDistanceFromEnd) {
                        break
                    }

                    // Always generate ticks from the start of the path rather than the span to ensure
                    // that ticks in repeat spans are positioned identically to those in non-repeat spans
                    val distanceProgress = d / length
                    val timeProgress = if (reversed) 1 - distanceProgress else distanceProgress
                    val tickPosition = position + path.positionAt(distanceProgress)

                    sliderTicks.add(
                        SliderTick(
                            spanStartTime + timeProgress * spanDuration,
                            tickPosition,
                            span,
                            spanStartTime
                        )
                    )

                    d += tickDistance
                }

                // For repeat spans, ticks are returned in reverse-StartTime order.
                if (reversed) {
                    sliderTicks.reverse()
                }

                nestedHitObjects.addAll(sliderTicks)
            }

            if (span < spanCount - 1) {
                nestedHitObjects.add(SliderRepeat(this, span))
            }
        }

        tail = SliderTail(this)

        nestedHitObjects.apply {
            add(tail)

            sortBy {
                scope?.ensureActive()

                it.startTime
            }
        }

        updateNestedSamples(controlPoints, scope)
    }

    private fun updateNestedPositions() {
        invalidateEndPositions()

        head.position = position
        tail.position = endPosition

        for (i in 1 until nestedHitObjects.size - 1) {
            val nestedHitObject = nestedHitObjects[i]
            val progress = (nestedHitObject.startTime - startTime) / duration

            nestedHitObject.position = position + curvePositionAt(progress)
        }
    }

    private fun invalidateEndPositions() {
        endPositionCache.invalidate()
        difficultyStackedEndPositionCache.invalidate()
        gameplayStackedEndPositionCache.invalidate()
        screenSpaceGameplayStackedEndPositionCache.invalidate()
    }

    private fun createSlidingSamples(controlPoints: BeatmapControlPoints, scope: CoroutineScope?) {
        auxiliarySamples.clear()

        val bankSamples = samples.filterIsInstance<BankHitSampleInfo>()
        val normalSlide = bankSamples.find { it.name == BankHitSampleInfo.HIT_NORMAL }
        val whistleSlide = bankSamples.find { it.name == BankHitSampleInfo.HIT_WHISTLE }

        if (normalSlide == null && whistleSlide == null) {
            return
        }

        val samplePoints = controlPoints.sample.between(startTime + CONTROL_POINT_LENIENCY, endTime + CONTROL_POINT_LENIENCY)

        if (normalSlide != null) {
            auxiliarySamples.add(SequenceHitSampleInfo(
                samplePoints.map {
                    scope?.ensureActive()

                    it.time to it.applyTo(baseNormalSlideSample)
                }
            ))
        }

        if (whistleSlide != null) {
            auxiliarySamples.add(SequenceHitSampleInfo(
                samplePoints.map {
                    scope?.ensureActive()

                    it.time to it.applyTo(baseWhistleSlideSample)
                }
            ))
        }
    }

    private fun updateNestedSamples(controlPoints: BeatmapControlPoints, scope: CoroutineScope?) {
        // Ensure that the list of node samples is at least as long as the number of nodes
        while (nodeSamples.size < repeatCount + 2) {
            scope?.ensureActive()

            nodeSamples.add(samples.map { it.copy() }.toMutableList())
        }

        nestedHitObjects.forEach {
            scope?.ensureActive()

            it.samples.clear()

            when (it) {
                is SliderHead -> it.samples.addAll(nodeSamples[0])
                is SliderRepeat -> it.samples.addAll(nodeSamples[it.spanIndex + 1])
                is SliderTail -> it.samples.addAll(nodeSamples[spanCount])
                else -> {
                    val time = it.startTime + CONTROL_POINT_LENIENCY
                    val tickSamplePoint = controlPoints.sample.controlPointAt(time)

                    it.samples.add(tickSamplePoint.applyTo(baseTickSample))
                }
            }
        }
    }

    companion object {
        const val LEGACY_LAST_TICK_OFFSET = 36.0

        /**
         * Scoring distance with a speed-adjusted beat length of 1 second (i.e. the speed slider balls move through their track).
         */
        const val BASE_SCORING_DISTANCE = 100f

        private val baseNormalSlideSample = BankHitSampleInfo("sliderslide")
        private val baseWhistleSlideSample = BankHitSampleInfo("sliderwhistle")
        private val baseTickSample = BankHitSampleInfo("slidertick")
    }
}
